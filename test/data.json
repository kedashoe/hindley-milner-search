[
  "create :: { checkTypes :: Boolean, env :: Array Type } -> Module",
  "env :: Array Type",
  "type :: a -> String",
  "is :: TypeRep a -> b -> Boolean",
  "I :: a -> a",
  "K :: a -> b -> a",
  "A :: (a -> b) -> a -> b",
  "T :: a -> (a -> b) -> b",
  "C :: (a -> b -> c) -> b -> a -> c",
  "B :: (b -> c) -> (a -> b) -> a -> c",
  "S :: (a -> b -> c) -> (a -> b) -> a -> c",
  "IntegFoo :: a -> b",
  "IntegBar :: Integer -> Bool",
  "curry2 :: ((a, b) -> c) -> a -> b -> c",
  "curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d",
  "curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e",
  "curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f",
  "flip :: ((a, b) -> c) -> b -> a -> c",
  "lift :: Functor f => (a -> b) -> f a -> f b",
  "lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c",
  "lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d",
  "compose :: (b -> c) -> (a -> b) -> a -> c",
  "pipe :: [(a -> b), (b -> c), ..., (m -> n)] -> a -> n",
  "on :: (b -> b -> c) -> (a -> b) -> a -> a -> c",
  "on_ :: ((b, b) -> c) -> (a -> b) -> a -> a -> c",
  "MaybeType :: Type -> Type",
  "Maybe :: TypeRep Maybe",
  "Nothing :: Maybe a",
  "Just :: a -> Maybe a",
  "Maybe.empty :: () -> Maybe a",
  "Maybe.of :: a -> Maybe a",
  "Maybe#@@type :: Maybe a ~> String",
  "Maybe#isNothing :: Maybe a ~> Boolean",
  "Maybe#isJust :: Maybe a ~> Boolean",
  "Maybe#toString :: Maybe a ~> () -> String",
  "Maybe#inspect :: Maybe a ~> () -> String",
  "Maybe#equals :: Maybe a ~> b -> Boolean",
  "Maybe#concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a",
  "Maybe#empty :: Maybe a ~> Maybe a",
  "Maybe#map :: Maybe a ~> (a -> b) -> Maybe b",
  "Maybe#ap :: Maybe (a -> b) ~> Maybe a -> Maybe b",
  "Maybe#of :: Maybe a ~> b -> Maybe b",
  "Maybe#chain :: Maybe a ~> (a -> Maybe b) -> Maybe b",
  "Maybe#filter :: Maybe a ~> (a -> Boolean) -> Maybe a",
  "Maybe#reduce :: Maybe a ~> ((b, a) -> b) -> b -> b",
  "Maybe#sequence :: Applicative f => Maybe (f a) ~> (a -> f a) -> f (Maybe a)",
  "Maybe#extend :: Maybe a ~> (Maybe a -> b) -> Maybe b",
  "isNothing :: Maybe a -> Boolean",
  "isJust :: Maybe a -> Boolean",
  "fromMaybe :: a -> Maybe a -> a",
  "maybeToNullable :: Maybe a -> Nullable a",
  "toMaybe :: a? -> Maybe a",
  "maybe :: b -> (a -> b) -> Maybe a -> b",
  "maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b",
  "justs :: Array (Maybe a) -> Array a",
  "mapMaybe :: (a -> Maybe b) -> Array a -> Array b",
  "encase :: (a -> b) -> a -> Maybe b",
  "encase2 :: (a -> b -> c) -> a -> b -> Maybe c",
  "encase2_ :: ((a, b) -> c) -> a -> b -> Maybe c",
  "encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d",
  "encase3_ :: ((a, b, c) -> d) -> a -> b -> c -> Maybe d",
  "maybeToEither :: a -> Maybe b -> Either a b",
  "EitherType :: Type -> Type -> Type",
  "Either :: TypeRep Either",
  "Left :: a -> Either a b",
  "Right :: b -> Either a b",
  "Either.of :: b -> Either a b",
  "Either#@@type :: Either a b ~> String",
  "Either#isLeft :: Either a b ~> Boolean",
  "Either#isRight :: Either a b ~> Boolean",
  "Either#toString :: Either a b ~> () -> String",
  "Either#inspect :: Either a b ~> () -> String",
  "Either#equals :: Either a b ~> c -> Boolean",
  "Either#concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b",
  "Either#map :: Either a b ~> (b -> c) -> Either a c",
  "Either#ap :: Either a (b -> c) ~> Either a b -> Either a c",
  "Either#of :: Either a b ~> c -> Either a c",
  "Either#chain :: Either a b ~> (b -> Either a c) -> Either a c",
  "Either#reduce :: Either a b ~> ((c, b) -> c) -> c -> c",
  "Either#sequence :: Applicative f => Either a (f b) ~> (b -> f b) -> f (Either a b)",
  "Either#extend :: Either a b ~> (Either a b -> c) -> Either a c",
  "isLeft :: Either a b -> Boolean",
  "isRight :: Either a b -> Boolean",
  "fromEither :: b -> Either a b -> b",
  "toEither :: a -> b? -> Either a b",
  "either :: (a -> c) -> (b -> c) -> Either a b -> c",
  "lefts :: Array (Either a b) -> Array a",
  "rights :: Array (Either a b) -> Array b",
  "encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r",
  "encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r",
  "encaseEither2_ :: (Error -> l) -> ((a, b) -> r) -> a -> b -> Either l r",
  "encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r",
  "encaseEither3_ :: (Error -> l) -> ((a, b, c) -> r) -> a -> b -> c -> Either l r",
  "eitherToMaybe :: Either a b -> Maybe b",
  "and :: Boolean -> Boolean -> Boolean",
  "or :: Boolean -> Boolean -> Boolean",
  "not :: Boolean -> Boolean",
  "ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b",
  "allPass :: Array (a -> Boolean) -> a -> Boolean",
  "anyPass :: Array (a -> Boolean) -> a -> Boolean",
  "concat :: Semigroup a => a -> a -> a",
  "slice :: Integer -> Integer -> List a -> Maybe (List a)",
  "at :: Integer -> List a -> Maybe a",
  "head :: List a -> Maybe a",
  "last :: List a -> Maybe a",
  "tail :: List a -> Maybe (List a)",
  "init :: List a -> Maybe (List a)",
  "take :: Integer -> List a -> Maybe (List a)",
  "takeLast :: Integer -> List a -> Maybe (List a)",
  "drop :: Integer -> List a -> Maybe (List a)",
  "dropLast :: Integer -> List a -> Maybe (List a)",
  "reverse :: List a -> List a",
  "indexOf :: a -> List a -> Maybe Integer",
  "lastIndexOf :: a -> List a -> Maybe Integer",
  "append :: a -> Array a -> Array a",
  "prepend :: a -> Array a -> Array a",
  "joinWith :: String -> Array String -> String",
  "find :: (a -> Boolean) -> Array a -> Maybe a",
  "pluck :: Accessible a => String -> Array a -> Array b",
  "reduce :: Foldable f => (a -> b -> a) -> a -> f b -> a",
  "reduce_ :: Foldable f => ((a, b) -> a) -> a -> f b -> a",
  "unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a",
  "range :: Integer -> Integer -> Array Integer",
  "prop :: Accessible a => String -> a -> b",
  "get :: Accessible a => TypeRep b -> String -> a -> Maybe b",
  "gets :: Accessible a => TypeRep b -> Array String -> a -> Maybe b",
  "keys :: StrMap a -> Array String",
  "values :: StrMap a -> Array a",
  "pairs :: StrMap a -> Array (Pair String a)",
  "negate :: ValidNumber -> ValidNumber",
  "add :: FiniteNumber -> FiniteNumber -> FiniteNumber",
  "sum :: Foldable f => f FiniteNumber -> FiniteNumber",
  "sub :: FiniteNumber -> FiniteNumber -> FiniteNumber",
  "inc :: FiniteNumber -> FiniteNumber",
  "dec :: FiniteNumber -> FiniteNumber",
  "mult :: FiniteNumber -> FiniteNumber -> FiniteNumber",
  "product :: Foldable f => f FiniteNumber -> FiniteNumber",
  "div :: FiniteNumber -> NonZeroFiniteNumber -> FiniteNumber",
  "mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber",
  "min :: Ord a => a -> a -> a",
  "max :: Ord a => a -> a -> a",
  "even :: Integer -> Boolean",
  "odd :: Integer -> Boolean",
  "parseDate :: String -> Maybe Date",
  "parseFloat :: String -> Maybe Number",
  "parseInt :: Integer -> String -> Maybe Integer",
  "parseJson :: TypeRep a -> String -> Maybe a",
  "regex :: RegexFlags -> String -> RegExp",
  "regexEscape :: String -> String",
  "test :: RegExp -> String -> Boolean",
  "match :: RegExp -> String -> Maybe (Array (Maybe String))",
  "toUpper :: String -> String",
  "toLower :: String -> String",
  "trim :: String -> String",
  "words :: String -> Array String",
  "unwords :: Array String -> String",
  "lines :: String -> Array String",
  "unlines :: Array String -> String",
  "splitOn :: String -> String -> Array String"
]
